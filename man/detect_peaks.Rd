% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/detect_peaks.R
\name{detect_peaks}
\alias{detect_peaks}
\title{Detect peaks in data based on their amplitude and other features}
\usage{
detect_peaks(x, mph = NA, mpd = 1, threshold = 0, edge = "rising",
  kpsh = FALSE, valley = FALSE, mpd_from_start = TRUE)
}
\arguments{
\item{x}{1-d array}

\item{mph}{(NA, number), optional (default = NA). Detect peaks wthat are greater than minimum peak height (if \code{valley=F}) or peaks that are smaller than minimum peak height (if \code{valley=T})}

\item{mpd}{positive integer, optional (default = 1). Detect peaks that are at least separated by minimum peak distance (in number of data)}

\item{threshold}{positive number, optional (default = 0). Detect peaks (valleys) that are greater (smaller) than  \code{threshold} in relation to their immediate neighbors}

\item{edge}{One of NA, \code{rising}, \code{falling} or \code{both}, optional (default = \code{rising}). for a flat peak, keep only the rising edge ('rising'), only the falling edge ('falling'), both edges ('both'), or don't detect a flat peak (None).}

\item{kpsh}{Boolean, optional (default = FALSE). Keep peaks with same height even if they are closer than \code{mpd}}

\item{valley}{Boolean, optional (default = FALSE). If TRUE, detect valleys (local minima) instead of peaks (local maxima)}

\item{mpd_from_start}{Boolean (default = TRUE) Should we start counting from beginning, or compute from highest peak (FALSE)}
}
\value{
a 1-d array with indices of the peaks in \code{x}
}
\description{
Translated from the Python version at https://github.com/demotu/BMC
License: MIT
Version: 1.0
}
\examples{

 x = rnorm(100)
 x[60:81] = NA
 # detect all peaks and plot data
 ind = detect_peaks(x, show=TRUE)
 print(ind)

 x = sin(2*pi*5*seq(0,1,length.out=200)) + rnorm(200)/5
 # set minimum peak height = 0 and minimum peak distance = 20
 detect_peaks(x, mph=0, mpd=20, show=TRUE)

 x = c(0, 1, 0, 2, 0, 3, 0, 2, 0, 1, 0)
 # set minimum peak distance = 2
 detect_peaks(x, mpd=2, show=TRUE)

 x = sin(2*pi*5*seq(0, 1, length.out=200)) + rnorm(200)/5
 # detection of valleys instead of peaks
 detect_peaks(x, mph=-1.2, mpd=20, valley=True, show=True)

 x =c(0, 1, 1, 0, 1, 1, 0)
 # detect both edges
 detect_peaks(x, edge='both', show=TRUE)

 x =c(-2, 1, -2, 2, 1, 1, 3, 0)
 # set threshold = 2
 detect_peaks(x, threshold = 2, show=TRUE)
}
