% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_peaks2.R
\name{detect_peaks}
\alias{detect_peaks}
\title{Detect peaks in data based on their amplitude and other features}
\usage{
detect_peaks(x, mph = NA, mpd = 1, threshold = 0, edge = "rising",
  kpsh = FALSE, valley = FALSE)
}
\arguments{
\item{x}{1-d array}

\item{mph}{(NA, number), optional (default = NA). Detect peaks wthat are greater than minimum peak height (if \code{valley=F}) or peaks that are smaller than maximum peak height (if \code{valley=T})}

\item{mpd}{positive integer, optional (default = 1). Detect peaks that are at least separated by minimum peak distance (in number of data)}

\item{threshold}{positive number, optional (default = 0). Detect peaks (valleys) that are greater (smaller) than  \code{threshold} in relation to their immediate neighbors}

\item{edge}{One of NA, \code{rising}, \code{falling} or \code{both}, optional (default = \code{rising}). for a flat peak, keep only the rising edge ('rising'), only the falling edge ('falling'), both edges ('both'), or don't detect a flat peak (None).}

\item{kpsh}{Boolean, optional (default = FALSE). Keep peaks with same height even if they are closer than \code{mpd}}

\item{valley}{Boolean, optional (default = FALSE). If TRUE, detect valleys (local minima) instead of peaks (local maxima)}
}
\value{
a 1-d array with indices of the peaks in \code{x}
}
\description{
Translated from the Python version at https://github.com/demotu/BMC
License: MIT
Version: 1.0
}
\examples{

> from detect_peaks import detect_peaks
> x = np.random.randn(100)
> x[60:81] = np.nan
> # detect all peaks and plot data
> ind = detect_peaks(x, show=True)
> print(ind)

> x = np.sin(2*np.pi*5*np.linspace(0, 1, 200)) + np.random.randn(200)/5
> # set minimum peak height = 0 and minimum peak distance = 20
> detect_peaks(x, mph=0, mpd=20, show=True)

> x = [0, 1, 0, 2, 0, 3, 0, 2, 0, 1, 0]
> # set minimum peak distance = 2
> detect_peaks(x, mpd=2, show=True)

> x = np.sin(2*np.pi*5*np.linspace(0, 1, 200)) + np.random.randn(200)/5
> # detection of valleys instead of peaks
> detect_peaks(x, mph=-1.2, mpd=20, valley=True, show=True)

> x = [0, 1, 1, 0, 1, 1, 0]
> # detect both edges
> detect_peaks(x, edge='both', show=True)

> x = [-2, 1, -2, 2, 1, 1, 3, 0]
> # set threshold = 2
> detect_peaks(x, threshold = 2, show=True)
}
